@*@model List<Kartverket.Models.AreaChange>*@
@model List<Kartverket.Data.Case>
@{
    ViewData["Title"] = "Overview";
}

<h2>Oversikt av registrerte endringer</h2>

<table class="table">
    <thead>
        <tr>
            <th>ID</th>
            <th>GeoJSON</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        @if (Model !=null)
        {
            @foreach (var change in Model)
            {
                <tr>
                <td>@change.CaseNo</td>
                <td>@change.LocationInfo</td>
                <td>@change.Description</td>
            </tr>
            }
        }
        else
        {
            <tr><td colspan="3">No data available</td></tr>
        }
    </tbody>
</table>

<div id="map" style="height: 500px;"></div>

@section Scripts {
    <script src="~/js/leafletMap.js"></script>
    <script src="~/js/leafletDraw.js"></script>

    <script>
              
        // Get the changes data from the model
        var changes = @Html.Raw(Json.Serialize(Model));

        // Initialize a feature group to hold all layers
        var allLayers = new L.FeatureGroup();
        map.addLayer(allLayers);

        // Process each change
        changes.forEach(function (change) {
            var geoJsonData = JSON.parse(change.geoJson);
            var layer = L.geoJSON(geoJsonData).bindPopup(change.description);
            allLayers.addLayer(layer);

            // Extract coordinates from GeoJSON
            var geocoordinates = geoJsonData.geometry.coordinates;
            if (geocoordinates && geocoordinates.length >= 2) {
                var latitude = geocoordinates[1];
                var longitude = geocoordinates[0];

                console.log(`Processing change ID ${change.Id} with coordinates: ${latitude}, ${longitude}`);

                // Construct the URL for reverse geocoding
                var url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`;

                // Fetch the address using reverse geocoding
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Network response was not ok: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log(`Received data for change ID ${change.Id}:`, data);
                        var address = data.display_name ? data.display_name : "Address not found";
                        var popupContent = `${change.description}<br>Address: ${address}`;
                        layer.setPopupContent(popupContent).openPopup();
                        console.log(`Popup updated for change ID ${change.Id}: ${popupContent}`);
                    })
                    .catch(error => {
                        var popupContent = `${change.description}<br>Address not available`;
                        layer.setPopupContent(popupContent).openPopup();
                        console.error(`Failed to update popup for change ID ${change.Id}: ${error}`);
                    });
            } else {
                console.error(`Invalid coordinates for change ID ${change.Id}`);
            }
        });

        // Fit the map bounds to all layers
        if (allLayers.getLayers().length > 0) {
            var bounds = allLayers.getBounds();
            console.log("Fitting bounds:", bounds);
            map.fitBounds(bounds);

            // Force map update
            map.invalidateSize();
        }

        // Handle the draw event
        map.on(L.Draw.Event.CREATED, function (e) {
            var type = e.layerType,
                layer = e.layer;

            // Add the new layer to the feature group
            allLayers.addLayer(layer);

            // Recalculate the bounds of all layers
            var bounds = allLayers.getBounds();
            console.log("Updated bounds:", bounds);

            if (bounds.isValid()) {
                console.log("Fitting updated bounds:", bounds);
                map.fitBounds(bounds);

                // Force map update
                map.invalidateSize();
            } else {
                console.error("Invalid updated bounds:", bounds);
            }
        });
    </script>
}